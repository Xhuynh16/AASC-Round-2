<%- contentFor('body') %>

<div class="row mt-4">
    <div class="col-lg-9">
        <div class="card">
            <div class="card-header bg-primary text-white d-flex justify-content-between align-items-center">
                <h4 class="mb-0">Cờ Caro</h4>
                <div id="gameStatus">Connecting to server...</div>
            </div>
            <div class="card-body p-4 text-center">
                <div id="waitingScreen" class="d-none">
                    <h3>Waiting for opponent...</h3>
                    <div class="mb-3">
                        <p>Share this Game ID with your friend:</p>
                        <div class="input-group">
                            <input type="text" id="shareGameId" class="form-control" readonly>
                            <button class="btn btn-outline-secondary" type="button" id="copyGameIdBtn">Copy</button>
                        </div>
                    </div>
                    <div class="spinner-border text-primary mt-3" role="status">
                        <span class="visually-hidden">Loading...</span>
                    </div>
                </div>
                
                <div id="gameScreen" class="d-none">
                    <div id="gameInfo" class="mb-3">
                        <div class="row">
                            <div class="col-md-4 text-start">
                        <p>You are playing as <span id="playerSymbol" class="fw-bold">X</span></p>
                            </div>
                            <div class="col-md-4">
                                <p>Game ID: <span id="currentGameId"></span></p>
                            </div>
                            <div class="col-md-4 text-end">
                        <p>Playing against: <span id="opponentName">Opponent</span></p>
                            </div>
                        </div>
                        <p id="turnInfo" class="bg-light p-2 rounded">Current turn: <span id="currentTurn" class="fw-bold">X</span></p>
                    </div>
                    
                    <div id="gameBoard" class="mb-3 mx-auto overflow-auto">
                        <!-- The 15x15 board will be generated dynamically -->
                    </div>
                    
                    <div id="gameResult" class="alert alert-success d-none"></div>
                    
                    <button id="restartButton" class="btn btn-primary d-none">Play Again</button>
                </div>
                
                <div id="joinScreen">
                    <div class="row">
                        <div class="col-md-6">
                            <div class="card mb-3">
                                <div class="card-header bg-success text-white">
                                    <h5 class="mb-0">Create New Game</h5>
                                </div>
                                <div class="card-body">
                                    <div class="mb-3">
                                        <label for="createUsername" class="form-label">Your Nickname</label>
                                        <input type="text" class="form-control" id="createUsername" placeholder="Enter your nickname">
                                    </div>
                                    <div class="mb-3">
                                        <label for="createGameId" class="form-label">Custom Game ID (optional)</label>
                                        <input type="text" class="form-control" id="createGameId" placeholder="Leave blank for random ID">
                                    </div>
                                    <button id="createButton" class="btn btn-success w-100">Create Game</button>
                                </div>
                            </div>
                        </div>
                        <div class="col-md-6">
                            <div class="card mb-3">
                                <div class="card-header bg-info text-white">
                                    <h5 class="mb-0">Join Existing Game</h5>
                                </div>
                                <div class="card-body">
                                    <div class="mb-3">
                                        <label for="joinUsername" class="form-label">Your Nickname</label>
                                        <input type="text" class="form-control" id="joinUsername" placeholder="Enter your nickname">
                                    </div>
                    <div class="mb-3">
                                        <label for="joinGameId" class="form-label">Game ID</label>
                                        <input type="text" class="form-control" id="joinGameId" placeholder="Enter game ID">
                                    </div>
                                    <button id="joinButton" class="btn btn-info w-100">Join Game</button>
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <div class="card mt-3">
                        <div class="card-header bg-secondary text-white">
                            <h5 class="mb-0">Available Games</h5>
                        </div>
                        <div class="card-body">
                            <div id="availableGames" class="list-group">
                                <div class="text-center p-3">
                                    <span class="spinner-border spinner-border-sm" role="status" aria-hidden="true"></span>
                                    Loading available games...
                                </div>
                            </div>
                            <button id="refreshGamesButton" class="btn btn-secondary mt-3">Refresh List</button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>
    <div class="col-lg-3">
        <div class="card">
            <div class="card-header bg-info text-white">
                <h5 class="mb-0">Game Rules</h5>
            </div>
            <div class="card-body">
                <p><strong>Cách chơi:</strong></p>
                <ul>
                    <li>Lần lượt đặt X hoặc O trên bàn cờ 15x15</li>
                    <li>Người chơi đầu tiên tạo được 5 quân liên tiếp sẽ thắng</li>
                    <li>Đường thẳng có thể là ngang, dọc hoặc chéo</li>
                    <li>Nếu bàn cờ đầy mà không có người thắng, trò chơi hòa</li>
                </ul>
                <p class="mt-3"><strong>Game ID:</strong></p>
                <ul>
                    <li>Tạo trò chơi với Game ID tùy chỉnh</li>
                    <li>Chia sẻ ID với bạn bè để chơi cùng nhau</li>
                </ul>
            </div>
        </div>
    </div>
</div>

<%- contentFor('stylesheets') %>
<style>
    .ttt-board {
        display: grid;
        grid-template-columns: repeat(15, 30px);
        grid-template-rows: repeat(15, 30px);
        gap: 1px;
        margin: 0 auto;
        background-color: #ddd;
        border: 1px solid #aaa;
        max-width: 100%;
        width: fit-content;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
    }
    
    .ttt-cell {
        width: 30px;
        height: 30px;
        min-width: 30px;
        min-height: 30px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 16px;
        font-weight: bold;
        background-color: white;
        border: 1px solid #eee;
        padding: 0;
        margin: 0;
        box-sizing: border-box;
    }
    
    .clickable {
        cursor: pointer;
    }
    
    .clickable:hover {
        background-color: rgba(0, 123, 255, 0.2);
        box-shadow: 0 0 2px rgba(0, 123, 255, 0.5);
    }
    
    #gameBoard {
        max-width: 100%;
        overflow-x: auto;
        overflow-y: auto;
        padding: 10px;
        display: flex;
        justify-content: center;
        align-items: center;
        margin: 0 auto;
    }
    
    #ttt-board-container {
        width: fit-content;
        margin: 0 auto;
    }
    
    .x-symbol {
        color: #0d6efd;
    }
    
    .o-symbol {
        color: #dc3545;
    }
    
    .winning-cell {
        background-color: rgba(255, 235, 59, 0.5);
    }

    /* Fix for mobile devices */
    @media (max-width: 768px) {
        #gameScreen {
            padding: 0;
        }
        
        #gameBoard {
            padding: 5px;
            max-height: 80vh;
        }
        
        .ttt-board {
            transform-origin: center;
            margin: 0 auto;
        }
        
        .ttt-cell {
            width: 25px;
            height: 25px;
            min-width: 25px;
            min-height: 25px;
            font-size: 14px;
        }
    }
    
    /* Enhance readability in game */
    #gameInfo {
        background-color: #f8f9fa;
        border-radius: 5px;
        padding: 10px;
        margin-bottom: 15px;
    }
    
    #turnInfo {
        font-weight: bold;
        padding: 8px;
        border-radius: 4px;
        text-align: center;
    }
</style>

<%- contentFor('scripts') %>
<script src="/socket.io/socket.io.js"></script>
<script>
    document.addEventListener('DOMContentLoaded', function() {
        // DOM elements
        const waitingScreen = document.getElementById('waitingScreen');
        const gameScreen = document.getElementById('gameScreen');
        const joinScreen = document.getElementById('joinScreen');
        const gameStatus = document.getElementById('gameStatus');
        const playerSymbol = document.getElementById('playerSymbol');
        const opponentName = document.getElementById('opponentName');
        const currentTurn = document.getElementById('currentTurn');
        const currentGameId = document.getElementById('currentGameId');
        const turnInfo = document.getElementById('turnInfo');
        const gameResult = document.getElementById('gameResult');
        const restartButton = document.getElementById('restartButton');
        const createButton = document.getElementById('createButton');
        const joinButton = document.getElementById('joinButton');
        const createUsername = document.getElementById('createUsername');
        const joinUsername = document.getElementById('joinUsername');
        const createGameId = document.getElementById('createGameId');
        const joinGameId = document.getElementById('joinGameId');
        const shareGameId = document.getElementById('shareGameId');
        const copyGameIdBtn = document.getElementById('copyGameIdBtn');
        const gameBoard = document.getElementById('gameBoard');
        const availableGames = document.getElementById('availableGames');
        const refreshGamesButton = document.getElementById('refreshGamesButton');
        
        // Game variables
        let socket = null;
        let gameId = null;
        let boardSize = 15;
        let board = Array(boardSize * boardSize).fill(null);
        let mySymbol = null;
        let isMyTurn = false;
        let socketConnected = false;
        
        // Initialize app when document is loaded
        initApp();
        
        function initApp() {
            console.log('Initializing Tic Tac Toe game app...');
            initSocket();
            
            // Set up button click handlers
            createButton.addEventListener('click', handleCreateGame);
            joinButton.addEventListener('click', handleJoinGame);
            refreshGamesButton.addEventListener('click', loadAvailableGames);
            restartButton.addEventListener('click', handleRestartGame);
            copyGameIdBtn.addEventListener('click', copyGameIdToClipboard);
            
            console.log('App initialization complete');
        }
        
        // Initialize the socket connection
        function initSocket() {
            try {
                // Clean up existing socket if any
                if (socket) {
                    socket.off();
                    socket.close();
                }
                
                // Create socket connection with explicit config
                socket = io('/tictactoe', {
                    reconnectionAttempts: 5,
                    timeout: 10000,
                    transports: ['websocket', 'polling']
                });
                
                // Debug socket object
                console.log('Socket object created:', socket);
            
            socket.on('connect', () => {
                    console.log('Socket connection established successfully');
                    socketConnected = true;
                    
                    // Update UI to show connected status
                    connectionStatus.textContent = 'Connected';
                    connectionStatus.classList.remove('text-danger');
                    connectionStatus.classList.add('text-success');
                    
                    // Enable game controls now that we are connected
                    document.querySelectorAll('.game-control-btn').forEach(btn => {
                        btn.disabled = false;
                    });
                    
                    // If we have a game ID from URL, rejoin the game automatically
                    if (gameId) {
                        console.log('Rejoining game:', gameId);
                        gameStatus.textContent = 'Rejoining game...';
                        
                        socket.emit('joinGame', { gameId: gameId }, function(response) {
                            console.log('Rejoin response:', response);
                            
                            if (response.success) {
                                console.log('Successfully rejoined game');
                                playerType = response.playerType;
                                mySymbol = playerType === 'host' ? 'X' : 'O';
                                updatePlayerInfo();
                                
                                // Get latest game state
                                requestGameState();
                            } else {
                                console.error('Failed to rejoin game:', response.message);
                                gameStatus.textContent = 'Failed to rejoin: ' + response.message;
                            }
                        });
                    }
                });
                
                socket.on('disconnect', () => {
                    console.log('Socket disconnected');
                    socketConnected = false;
                    connectionStatus.textContent = 'Disconnected';
                    connectionStatus.classList.remove('text-success');
                    connectionStatus.classList.add('text-danger');
                    
                    // Disable game controls when disconnected
                    document.querySelectorAll('.game-control-btn').forEach(btn => {
                        btn.disabled = true;
                    });
                    
                    gameStatus.textContent = 'Connection lost. Please wait or refresh the page.';
                });
                
                socket.on('connect_error', (error) => {
                    console.error('Socket connection error:', error);
                    socketConnected = false;
                    connectionStatus.textContent = 'Connection Error';
                    connectionStatus.classList.remove('text-success');
                    connectionStatus.classList.add('text-danger');
                    
                    gameStatus.textContent = 'Cannot connect to game server. Please check your internet connection.';
            });
            
            socket.on('waiting', (data) => {
                    console.log('Waiting for opponent', data);
                    joinScreen.classList.add('d-none');
                    waitingScreen.classList.remove('d-none');
                    gameStatus.textContent = 'Waiting for opponent';
                    
                    if (data.gameId) {
                        shareGameId.value = data.gameId;
                        gameId = data.gameId;
                    }
                });
                
                socket.on('gameCreated', (data) => {
                    console.log('Game created', data);
                    gameId = data.gameId;
                    boardSize = data.boardSize;
                    board = Array(boardSize * boardSize).fill(null);
                    mySymbol = data.yourSymbol;
                    
                    // Show waiting screen until opponent joins
                joinScreen.classList.add('d-none');
                waitingScreen.classList.remove('d-none');
                gameStatus.textContent = 'Waiting for opponent';
                    
                    if (data.gameId) {
                        shareGameId.value = data.gameId;
                    }
                    
                    // Generate board
                    generateBoard();
            });
            
            socket.on('gameStarted', (data) => {
                console.log('Game started', data);
                joinScreen.classList.add('d-none');
                waitingScreen.classList.add('d-none');
                gameScreen.classList.remove('d-none');
                
                gameId = data.gameId;
                board = data.board;
                    boardSize = data.boardSize;
                mySymbol = data.yourSymbol;
                opponentName.textContent = data.opponent.username;
                playerSymbol.textContent = mySymbol;
                playerSymbol.className = mySymbol === 'X' ? 'fw-bold x-symbol' : 'fw-bold o-symbol';
                    currentGameId.textContent = gameId;
                
                isMyTurn = mySymbol === data.currentTurn;
                currentTurn.textContent = data.currentTurn;
                currentTurn.className = data.currentTurn === 'X' ? 'fw-bold x-symbol' : 'fw-bold o-symbol';
                    
                    // Generate board if not already generated
                    if (gameBoard.children.length === 0) {
                        generateBoard();
                    }
                
                updateBoard();
                updateTurnInfo();
                    setupGameControls();
                    
                    // After game starts, request game state to ensure we have the latest state
                    setTimeout(() => requestGameState(), 500);
                
                gameStatus.textContent = 'Game in progress';
            });
            
            socket.on('gameUpdated', (data) => {
                    console.log('Socket event received: gameUpdated', data);
                    
                    if (!data) {
                        console.error('Empty gameUpdated data received');
                        setTimeout(() => requestGameState(), 1000);
                        return;
                    }
                    
                    // Verify this update is for our game
                    if (data.gameId && data.gameId !== gameId) {
                        console.warn('Received update for different game:', data.gameId, 'Current game:', gameId);
                        return;
                    }
                    
                    // Update the game board with new data
                    if (data.board) {
                        console.log('Updating board with new data:', data.board);
                        board = data.board;
                        updateBoard();
                    }
                    
                    // Update turn info
                    if (data.currentTurn) {
                        console.log('Current turn:', data.currentTurn, 'My symbol:', mySymbol);
                        isMyTurn = data.currentTurn === mySymbol;
                        currentTurn.textContent = data.currentTurn;
                        currentTurn.className = data.currentTurn === 'X' ? 'fw-bold x-symbol' : 'fw-bold o-symbol';
                        updateTurnInfo();
                    }
                    
                    // Enable or disable the board based on whose turn it is
                    const pointerEvents = isMyTurn ? 'auto' : 'none';
                    document.querySelectorAll('.ttt-cell').forEach(cell => {
                        const pos = parseInt(cell.dataset.position);
                        if (!board[pos]) {
                            cell.style.pointerEvents = pointerEvents;
                        }
                    });
                    
                    // Update game status text
                    if (data.status === 'playing') {
                        gameStatus.textContent = isMyTurn ? 'Your turn' : 'Opponent\'s turn';
                    } else if (data.status === 'finished') {
                        handleGameEnd(data.winner, data.winningCells);
                    }
                });
            
            socket.on('gameRestarted', (data) => {
                console.log('Game restarted', data);
                    
                    if (!data) {
                        console.error('Received empty gameRestarted event');
                        return;
                    }
                    
                    // Update local board data
                    if (data.board) {
                board = data.board;
                    }
                    
                    if (data.currentTurn) {
                isMyTurn = mySymbol === data.currentTurn;
                currentTurn.textContent = data.currentTurn;
                currentTurn.className = data.currentTurn === 'X' ? 'fw-bold x-symbol' : 'fw-bold o-symbol';
                    }
                
                // Clear winning cells highlight
                const cells = document.querySelectorAll('.ttt-cell');
                cells.forEach(cell => {
                    cell.classList.remove('winning-cell');
                });
                
                    // Update UI
                updateBoard();
                updateTurnInfo();
                
                    // Hide result message & show turn info
                gameResult.classList.add('d-none');
                turnInfo.classList.remove('d-none');
                
                    // Update game status
                gameStatus.textContent = 'Game in progress';
            });
            
            socket.on('playerLeft', (data) => {
                console.log('Opponent left', data);
                alert('Your opponent has left the game.');
                resetGame();
            });
                
                // Debug event to ensure events are properly registered
                socket.on('connect', function() {
                    console.log('Socket connected with ID:', socket.id);
                    console.log('Socket events registered');
                });
                
                // Debug all received messages
                socket.onAny((event, ...args) => {
                    console.log('Socket event received:', event, args);
                });
                
                // Also handle failed connections
                socket.on('connect_error', function(error) {
                    console.error('Socket connection error:', error);
                    gameStatus.textContent = 'Connection error';
                });
                
                // Add explicit registration for makeMove event
                socket.on('makeMove_response', function(data) {
                    console.log('Make move response received:', data);
                });
                
            } catch (error) {
                console.error('Socket initialization error:', error);
                gameStatus.textContent = 'Socket error';
                throw error;
            }
        }
        
        // Generate the board
        function generateBoard() {
            console.log('Generating board, size:', boardSize);
            gameBoard.innerHTML = '';
            
            const boardElement = document.createElement('div');
            boardElement.classList.add('ttt-board');
            boardElement.id = 'ttt-board-container';
            
            // Ensure board dimensions are explicitly set
            boardElement.style.gridTemplateColumns = `repeat(${boardSize}, 30px)`;
            boardElement.style.gridTemplateRows = `repeat(${boardSize}, 30px)`;
            
            // Create all cells
            for (let row = 0; row < boardSize; row++) {
                for (let col = 0; col < boardSize; col++) {
                    const position = row * boardSize + col;
                    
                    const cell = document.createElement('div');
                    cell.classList.add('ttt-cell');
                    cell.dataset.position = position.toString();
                    cell.dataset.row = row.toString();
                    cell.dataset.col = col.toString();
                    
                    // Add click handler directly (not using lambda to avoid potential issues)
                    cell.addEventListener('click', function() {
                        handleCellClick(parseInt(this.dataset.position));
                    });
                    
                    boardElement.appendChild(cell);
                }
            }
            
            gameBoard.appendChild(boardElement);
            console.log('Board generated with', boardSize*boardSize, 'cells');
            
            // Update cell content and interactivity
            updateBoard();
        }
        
        // Update the board UI based on the current state
        function updateBoard() {
            console.log('Updating board UI with data:', board ? board.length : 'no board');
            
            if (!board || !Array.isArray(board)) {
                console.error('Invalid board data:', board);
                return;
            }
            
            const cells = document.querySelectorAll('.ttt-cell');
            if (cells.length === 0) {
                console.log('No cells found, generating board first');
                generateBoard();
                return;
            }
            
            console.log(`Updating ${cells.length} cells with ${board.length} board positions`);
            
            // Update each cell's content and style
            cells.forEach((cell, index) => {
                if (index >= board.length) {
                    console.warn(`Cell index ${index} exceeds board length ${board.length}`);
                    return;
                }
                
                const value = board[index];
                
                // Update content
                cell.textContent = value || '';
                
                // Update styling
                cell.classList.remove('x-symbol', 'o-symbol', 'clickable');
                
                if (value === 'X') {
                    cell.classList.add('x-symbol');
                } else if (value === 'O') {
                    cell.classList.add('o-symbol');
                }
                
                // Make empty cells clickable during player's turn
                if (!value && isMyTurn) {
                    cell.classList.add('clickable');
                    cell.style.pointerEvents = 'auto';
                } else {
                    cell.style.pointerEvents = 'none';
                }
            });
            
            // Update turn info for better UX
            updateTurnInfo();
            console.log('Board UI updated successfully');
        }
        
        // Function to request current game state from server
        function requestGameState() {
            if (!socketConnected) {
                console.warn('Cannot request game state: Socket not connected');
                return;
            }
            
            if (!gameId) {
                console.warn('Cannot request game state: No gameId available');
                gameStatus.textContent = 'Error: No game ID';
                return;
            }
            
            console.log('Requesting current game state for game:', gameId);
            gameStatus.textContent = 'Syncing game state...';
            
            // Use string for gameId to avoid serialization issues
            socket.emit('requestGameState', gameId, function(response) {
                console.log('Game state response:', response);
                
                if (response && response.success) {
                    // Update game with received data
                    if (response.gameState) {
                        console.log('Received game state:', response.gameState);
                        
                        // Update board
                        board = response.gameState.board;
                        
                        // Update UI based on game status
                        if (response.gameState.status === 'waiting') {
                            // Show waiting screen if we're still waiting for opponent
                            joinScreen.classList.add('d-none');
                            gameScreen.classList.add('d-none');
                            waitingScreen.classList.remove('d-none');
                            gameStatus.textContent = 'Waiting for opponent to join...';
                            return;
                        } else {
                            // Show game screen for playing or finished games
                            joinScreen.classList.add('d-none');
                            waitingScreen.classList.add('d-none');
                            gameScreen.classList.remove('d-none');
                        }
                        
                        updateBoard();
                        
                        // Update turn info
                        if (response.gameState.currentTurn) {
                            isMyTurn = response.gameState.currentTurn === mySymbol;
                            currentTurn.textContent = response.gameState.currentTurn;
                            currentTurn.className = response.gameState.currentTurn === 'X' ? 'fw-bold x-symbol' : 'fw-bold o-symbol';
                            updateTurnInfo();
                        }
                        
                        // Enable or disable the board based on whose turn it is
                        const pointerEvents = isMyTurn ? 'auto' : 'none';
                        document.querySelectorAll('.ttt-cell').forEach(cell => {
                            const pos = parseInt(cell.dataset.position);
                            if (!board[pos]) {
                                cell.style.pointerEvents = pointerEvents;
                            }
                        });
                        
                        // Update game status
                        if (response.gameState.status === 'playing') {
                            gameStatus.textContent = isMyTurn ? 'Your turn' : 'Opponent\'s turn';
                        } else if (response.gameState.status === 'finished') {
                            handleGameEnd(response.gameState.winner, response.gameState.winningCells);
                        }
                    } else {
                        console.error('Game state response success but no data');
                        gameStatus.textContent = 'Failed to get game state';
                    }
                } else {
                    console.error('Failed to get game state:', response ? response.error : 'No response');
                    gameStatus.textContent = 'Error: ' + (response ? response.error : 'Could not get game state');
                }
            });
        }
        
        // Handle cell click with direct event sending
        function handleCellClick(index) {
            if (!isMyTurn || board[index] !== null) {
                return;
            }
            
            console.log('Cell clicked:', index);
            
            // Disable further clicks until server confirms move
            document.querySelectorAll('.ttt-cell').forEach(cell => {
                cell.style.pointerEvents = 'none';
            });
            
            // Show sending status to user
            gameStatus.textContent = 'Sending move...';
            
            // Make sure gameId is properly set
            if (!gameId) {
                console.error('No game ID available');
                gameStatus.textContent = 'Error: No game ID available';
                return;
            }
            
            // First request the current game state to ensure the game is in playing state
            socket.emit('requestGameState', gameId, function(stateResponse) {
                if (stateResponse && stateResponse.success && stateResponse.gameState) {
                    if (stateResponse.gameState.status !== 'playing') {
                        console.error('Game is not in playing state:', stateResponse.gameState.status);
                        gameStatus.textContent = `Error: Game is not in playing state: ${stateResponse.gameState.status}`;
                        
                        // Re-enable board if needed
                        if (stateResponse.gameState.status === 'playing' && isMyTurn) {
                            document.querySelectorAll('.ttt-cell').forEach(cell => {
                                if (!board[parseInt(cell.dataset.position)]) {
                                    cell.style.pointerEvents = 'auto';
                                }
                            });
                        } else {
                            // Update UI based on actual state
                            requestGameState();
                        }
                        return;
                    }
                    
                    console.log('Sending move data to server:', { gameId, position: index });
                    
                    // Set a timeout to handle server not responding
                    const moveTimeout = setTimeout(() => {
                        console.error('Server did not respond to move within 5 seconds');
                        gameStatus.textContent = 'Server not responding, please try again';
                        
                        // Re-enable board
                        document.querySelectorAll('.ttt-cell').forEach(cell => {
                            if (!board[parseInt(cell.dataset.position)]) {
                                cell.style.pointerEvents = 'auto';
                            }
                        });
                        
                        // Request current game state to recover
                        requestGameState();
                    }, 5000);
                    
                    // Send move directly with separate parameters
                    socket.emit('makeMove', gameId, index, function(response) {
                        clearTimeout(moveTimeout);
                        
                        console.log('Move response received:', response);
                        
                        if (response && response.success) {
                            gameStatus.textContent = 'Move sent successfully';
                        } else {
                            // Handle error
                            console.error('Error making move:', response ? response.error : 'No response');
                            gameStatus.textContent = response ? response.error : 'Error making move';
                            
                            // Re-enable board
                            document.querySelectorAll('.ttt-cell').forEach(cell => {
                                if (!board[parseInt(cell.dataset.position)]) {
                                    cell.style.pointerEvents = 'auto';
                                }
                            });
                        }
                    });
                } else {
                    console.error('Failed to check game state before move:', stateResponse ? stateResponse.error : 'No response');
                    gameStatus.textContent = 'Error checking game state';
                    
                    // Re-enable board
                    document.querySelectorAll('.ttt-cell').forEach(cell => {
                        if (!board[parseInt(cell.dataset.position)]) {
                            cell.style.pointerEvents = 'auto';
                        }
                    });
                }
            });
        }
        
        // Update the turn information
        function updateTurnInfo() {
            if (isMyTurn) {
                turnInfo.textContent = 'Your turn!';
                turnInfo.classList.add('bg-warning');
                turnInfo.classList.remove('bg-light');
            } else {
                turnInfo.textContent = `Waiting for ${opponentName.textContent}'s move...`;
                turnInfo.classList.remove('bg-warning');
                turnInfo.classList.add('bg-light');
            }
        }
        
        // Load available games
        function loadAvailableGames() {
            socket.emit('listGames', {}, (response) => {
                availableGames.innerHTML = '';
                
                if (response.games && response.games.length > 0) {
                    response.games.forEach(game => {
                        const gameItem = document.createElement('a');
                        gameItem.href = '#';
                        gameItem.classList.add('list-group-item', 'list-group-item-action', 'd-flex', 'justify-content-between', 'align-items-center');
                        gameItem.innerHTML = `
                            <span>Game <b>${game.id}</b> created by <b>${game.createdBy}</b></span>
                            <button class="btn btn-sm btn-primary join-game-btn" data-game-id="${game.id}">Join</button>
                        `;
                        
                        const joinBtn = gameItem.querySelector('.join-game-btn');
                        joinBtn.addEventListener('click', (e) => {
                            e.preventDefault();
                            joinGameById(game.id);
                        });
                        
                        availableGames.appendChild(gameItem);
                    });
                } else {
                    availableGames.innerHTML = '<div class="text-center p-3">No games available. Create one!</div>';
                }
            });
        }
        
        // Join a game by ID
        function joinGameById(id) {
            const username = joinUsername.value || 'Player ' + Math.floor(Math.random() * 1000);
            
            socket.emit('joinGame', { username, gameId: id }, (response) => {
                if (response.error) {
                    alert(response.error);
                }
            });
        }
        
        // Handle game end (win, lose, or draw)
        function handleGameEnd(winner, winningCells) {
            let resultMessage = '';
            
            if (winner === 'draw') {
                resultMessage = 'Game ended in a draw!';
                gameResult.classList.add('alert-info');
                gameResult.classList.remove('alert-success', 'alert-danger');
            } else {
                // Highlight winning cells
                if (winningCells && winningCells.length) {
                    const cells = document.querySelectorAll('.ttt-cell');
                    winningCells.forEach(position => {
                        cells[position].classList.add('winning-cell');
                    });
                }
                
                if (winner === mySymbol) {
                    resultMessage = 'You won!';
                    gameResult.classList.add('alert-success');
                    gameResult.classList.remove('alert-info', 'alert-danger');
                } else {
                    resultMessage = 'You lost!';
                    gameResult.classList.add('alert-danger');
                    gameResult.classList.remove('alert-success', 'alert-info');
                }
            }
            
            gameResult.textContent = resultMessage;
            gameResult.classList.remove('d-none');
            turnInfo.classList.add('d-none');
            restartButton.classList.remove('d-none');
            
            gameStatus.textContent = 'Game finished';
        }
        
        // Reset the game state
        function resetGame() {
            board = Array(boardSize * boardSize).fill(null);
            isMyTurn = false;
            gameId = null;
            
            // Reset UI
            gameScreen.classList.add('d-none');
            waitingScreen.classList.add('d-none');
            joinScreen.classList.remove('d-none');
            
            gameResult.classList.add('d-none');
            restartButton.classList.add('d-none');
            
            // Clear the board
            gameBoard.innerHTML = '';
            
            // Reload available games
            loadAvailableGames();
            
            gameStatus.textContent = 'Connected';
        }
        
        // Create new game
        function handleCreateGame() {
            const username = createUsername.value.trim() || 'Player ' + Math.floor(Math.random() * 1000);
            const customGameId = createGameId.value.trim();
            
            logGameAction('createGame', { username, customGameId });
            
            if (!socket || !socket.connected) {
                alert('Not connected to server. Please refresh the page.');
                return;
            }
            
            // Disable button to prevent double-clicks
            createButton.disabled = true;
            
            socket.emit('createGame', { 
                username: username,
                gameId: customGameId || undefined
            }, function(response) {
                createButton.disabled = false;
                
                if (!response) {
                    console.error('No response from server');
                    alert('Error creating game. Please try again.');
                    return;
                }
                
                if (response.error) {
                    console.error('Create game error:', response.error);
                    alert(response.error);
                }
            });
        }
        
        // Join existing game
        function handleJoinGame() {
            const username = joinUsername.value.trim() || 'Player ' + Math.floor(Math.random() * 1000);
            const gameIdToJoin = joinGameId.value.trim();
            
            if (!gameIdToJoin) {
                alert('Please enter a Game ID to join.');
                return;
            }
            
            logGameAction('joinGame', { username, gameId: gameIdToJoin });
            
            if (!socket || !socket.connected) {
                alert('Not connected to server. Please refresh the page.');
                return;
            }
            
            // Disable button to prevent double-clicks
            joinButton.disabled = true;
            
            socket.emit('joinGame', { 
                username: username,
                gameId: gameIdToJoin
            }, function(response) {
                joinButton.disabled = false;
                
                if (!response) {
                    console.error('No response from server');
                    alert('Error joining game. Please try again.');
                    return;
                }
                
                if (response.error) {
                    console.error('Join game error:', response.error);
                    alert(response.error);
                }
            });
        }
        
        // Restart game
        function handleRestartGame() {
            if (!gameId) {
                console.error('No gameId available');
                alert('Game ID not found. Please refresh the page.');
                return;
            }
            
            if (!socket || !socket.connected) {
                alert('Not connected to server. Please refresh the page.');
                return;
            }
            
            logGameAction('restartGame', { gameId });
            
            // Disable button to prevent double-clicks
            restartButton.disabled = true;
            
            socket.emit('restartGame', { gameId }, function(response) {
                restartButton.disabled = false;
                
                if (!response) {
                    console.error('No response from server');
                    alert('Error restarting game. Please try again.');
                    return;
                }
                
                if (response.error) {
                    console.error('Restart game error:', response.error);
                    alert(response.error);
                } else {
            restartButton.classList.add('d-none');
                }
            });
        }
        
        // Copy game ID to clipboard
        function copyGameIdToClipboard() {
            if (!shareGameId.value) {
                alert('No game ID available');
                return;
            }
            
            try {
                shareGameId.select();
                document.execCommand('copy');
                
                // Visual feedback
                const originalText = copyGameIdBtn.textContent;
                copyGameIdBtn.textContent = 'Copied!';
                copyGameIdBtn.classList.add('btn-success');
                copyGameIdBtn.classList.remove('btn-outline-secondary');
                
                // Reset after a delay
                setTimeout(() => {
                    copyGameIdBtn.textContent = originalText;
                    copyGameIdBtn.classList.remove('btn-success');
                    copyGameIdBtn.classList.add('btn-outline-secondary');
                }, 2000);
                
                console.log('Game ID copied to clipboard:', shareGameId.value);
            } catch (err) {
                console.error('Failed to copy text:', err);
                alert('Failed to copy. Please copy manually.');
            }
        }
        
        // Log game related actions for debugging
        function logGameAction(action, data) {
            console.log(`Game Action: ${action}`, data);
        }

        // Add a refresh button to the game screen to manually request game state
        function setupGameControls() {
            const gameInfo = document.getElementById('gameInfo');
            if (!gameInfo) return;
            
            // Create refresh button if it doesn't exist
            if (!document.getElementById('refreshGameStateBtn')) {
                const refreshBtn = document.createElement('button');
                refreshBtn.id = 'refreshGameStateBtn';
                refreshBtn.className = 'btn btn-sm btn-outline-secondary ms-2';
                refreshBtn.innerHTML = '<i class="bi bi-arrow-clockwise"></i> Refresh';
                refreshBtn.addEventListener('click', requestGameState);
                
                // Add the button next to turn info
                document.getElementById('turnInfo').appendChild(refreshBtn);
            }
        }
    });
</script> 